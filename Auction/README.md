# Описание задачи.

Аукцион - площадка, где на продажу выставляется нечто (Лоты).  

Лот (Auction.Models.Lot) - это некий "товар" у которого есть идентификатор, количество и цена.  

Имеется поток данных с аукционов.  
Поток представляет собой набор данных, содержащих сами Лоты и действия над пими ("Лот добавлен", "Лот изменен", "Лот снят/отменен").  
+ Auction.Models.LotUpdate - информация о конкретном лоте.
+ Auction.Models.Updates - очередной блок обновлений (обновления приходят не по одному лоту, а блоками).

Аукционов несколько, у каждого есть строковое имя.   
Данные разных аукционов не смешиваются - Аукционы полностью независимы

**Требуется: написать класс накопитель/оптимизатор потока данных - Throttler.**  
Задача класса заключается в том, чтобы принимать блоки обновлений (Auction.Models.Updates) и по запросу
выдавать объединенный блок обновлений (тоже Auction.Models.Updates, содержащий только актуальные данные.
___	
**Под актуальностью данных имеется ввиду следующее:**   
*если в блоке #1 пришла информация о появлении лота #15,
а блоке #2 пришла информация об отмене лота #15, то в объединенном блоке информация о лоте #15 должна отсутствовать,
т.к. лота #15 теперь нет и получателю не интересно, что он когда-то был.*

**Другой пример:** *если в блоке #6 пришла информация о появлении лота #23, а блоке #7 пришла информация об изменении лота #23,
то в объединенном блоке должна быть информация о появлении лота #23, но с содержимым из обновления №7 (уже после изменения),
т.к. лот #23 для получателя только появился, но должен содержать актуальные данные.*
___
Каждый блок обновлений (как на "вход", так и на "выход") содержит данные только для одного конкретного аукциона,
указанного в параметре auction_name

Реализация должна быть выполнена в виде класса Throttler отнаследованного от абстрактного класса ThrottlerBase.
+ Через функцию PutUpdate внешний источник помещает данные в Throttler.
+ Через функцию PopUpdates внешний получатель периодически забирает из Throttler'а все накопленные к моменту вызова данные.
 (после вызова Throttler начинает копить данные снова)
  
частота вызова PutUpdates и PopUpdates заранее не известна, но известно, что она очень большая (тысячи раз в секунду)   

***Важно!!!  
PutUpdates всегда вызывается из одного конкретного потока, а PopUpdates, всегда из разных
(их несколько и они не совпадают с потоком PutUpdates)***
 